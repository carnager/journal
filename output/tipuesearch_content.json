{"pages":[{"tags":"computer","text":"The issue Every once in a while some user joins #mpd and asks how albums with several artists can be grouped together instead of displaying each artist individually in library. And while I agree that this is annoying, their assumptions are wrong. They assume this is a player issue, while in reality it's caused by missing tags in the music files. Say hello to the albumartist tag The solution is in fact relatively simple. The artist tag that everyone knows just represents the artist for the current title. There is another artist tag, called \"albumartist\", which represents the artist of the album. Wrong usage of albumartist - a common problem Many users know the albumartist tag, but only tag their Multi-artist albums accordingly. This is wrong, because for this to work, the music player has to make exceptions what to do with files that don't have an albumartist tag. You see: EVERY album has a global artist. It just happens to be the same artist for all tracks on regular albums. It's still a album-related artist. Long story short: Every album needs an albumartist tag. For regular albums the albumartist tag is the same as the artist tag. For multi-artist releases it can be something like \"Various Artists\" or \"Soundtrack\" I have thousands of albums, how to sort this mess? Don't worry, the process of fixing your files is a short one. It's a 2 step process. 1. Fixing of your multi-artist releases. First step is to get a tagger, for this example I use the excellent picard tagger. Install it from your repository. Now load all your multi-artist albums into it, by simply dragging the folders on picards window. When all files were properly added, select them all and watch the lower part of picards window. As you can see my files already have the albumartist tag. If you have such a line too, simply click in the right column and give it a name (e.g. Various Artists) If no \"Album Artist\" line is visible right click and chose \"Add New Tag\" type \"albumartist\" and fill the value as above. Now make sure that \"Move Files\" and \"Rename Files\" is disabled in the Options menu on top. Finally hit save. You have successfully fixed your Multi-Artist albums. 2. Fix your regular albums But remember, all albums need an albumartist tag. Luckily ncmpcpp has a little tool to fix this automatically for you, but we need to build it. Open a terminal. Create an empty directory and cd into it. run these commands: wget http://repo.or.cz/w/ncmpcpp.git/blob_plain/HEAD:/extras/Makefile wget http://repo.or.cz/w/ncmpcpp.git/blob_plain/HEAD:/extras/artist_to_albumartist.cpp make This will build a little programm, called artist_to_albumartist, that you can find in the same directory now. To use it simply run this command: find /PATH/TO/YOUR/MUSIC \\( -name \"*.flac\" -o -name \"*.mp3\" -o -name \"*.ogg\" \\) -exec ./artist_to_albumartist {} \\; Replace /PATH/TO/YOUR/MUSIC with your actual music root. This will copy the artist tag of all files to the albumartist tag, skipping those files that already have one (aka the multi-artist releases we fixed earlier) Finally to make ncmpcpp use this new tag add this to your ~/.ncmpcpp/config file: media_library_primary_tag = \"album_artist\" Result See the same track from first image properly grouped under its album:","loc":"https://journal.53280.de/mpd.html","title":"Grouping VA albums in mpd"},{"tags":"rofi, mpd","text":"History Back in march I wrote about mpdMenu . It basically used mpc and dmenu to create lists of albums/files that were displayed in dmenu. It had some nice features like rating albums/tracks but to be honest it seemed a little rough around the edges. Those times are over now. mpdMenu is history. Long live clerk. clerk is basically the same thing as mpdMenu was, but it's presented in a much nicer way. I cleaned up the whole menu structure and i think it looks rather nice now. But let's see what clerk can actually do. Features Let's first have a look at the main menu. The Main Menu Nothing too exciting here. Play a random album, play random tracks. The number of tracks can be configured in the options menu, which we will look at later. Browsing Current Artist The next section covers actual browsing functionality. The current artist menu allows you to browse all albums or tracks by the artist currently playing in mpd. Do you see the section that says \"Adding Mode: Add\"? Clicking this will change the Mode to either \"Insert\" or \"Replace\" so you can decide how the actual album will be handled in the queue. Current Queue The Current Queue menu will show what it says: mpd's current queue. It has 2 modes: Play and Delete. Play will simply change playback to the chosen song, whereas Delete will remove items from the queue. Manage Playlists The Manage Playlists menu allows you to save, crop and clear the current playlist - or load an already saved one. It will ask for a filename and even warn you if the playlist already exists. In addition to this, you will find options to load an RSS Feed (those should be manually put in a file called podcasts in clerk's config directory) There are also entries to suspend or resume the current queue. This is very handy if you are listening to a podcast and want to continue later. Just suspend the playlist, listen to whatever you want and later resume it. It will load the state of the playlist and the position of the active track. Browsing the Database Clerk offers several ways to browse the database. First there is the hierarchical browser, which let's you first chose an artist and displays all albums related to it. If you chose to browse even deeper it will show all tracks of the given album. At any point in the library it's possible to add/insert/replace every shown artist/album/track. If you use rofi it is even possible to add several songs at once, by hitting Shift+Enter. It's also possible to browse the Database by date, list all albums. Last but not least clerk can show you all songs in database. Each browser can add, insert or replace the results into the queue. Speaking of insert mode. This is one thing that most mpd clients get wrong, imho. You see, insert in mpd means, that the track will be placed right after the one that is currently playing. Which works fine, as long as you are not in random mode. For this scenario mpd offers a feature called \"Priorities\", which can set a weight to songs in the playlist. Sounds like a good solution, but the developer of mpd only made it available for random mode. In normal playback mode weights are ignored. So there are some clients that support priorities. But they seperate it from the \"Insert\" command. Which seems wrong to me, because all in all you always want the same thing, be it in random mode or not: Play that goddamn song NEXT. Well, this is exactly what clerk does. Insert will always play the selected songs next. No matter what mode mpd is in. Nice. A word about mpc For the tracks and album listings I really wanted to have a way to show a nice tag based view. Which turned out to be not-easy at all. Why is that? Well there are actually 2 issues here, which both needed solving. First of all mpd does not allow to list albums or tracks in a formatted way. This basically means that you have to fetch the whole database with all tags just to display one part of the information (in this case either title or album). This is slow. very. I worked around this by creating a cache for clerk. Clerk will automatically detect if the mpd database has changed since the last time. If it has it will update its local cache. No user interaction needed. But there was another issue. mpc only knows the listall command (which only sends URIs) - not the listallinfo (which sends tags). But I wanted those nice formatted views! So I took the hard road and started developing a python clone of mpc. I simply called mppc (music player python client). It's an explicit dependency for clerk and is used in quite some places. Not only does it allow for the formatted album/track view, but it also adds readcomments support to clerk, a feature mpd offers for nearly a year now, but I havent seen a single client using it. With readcomments it's possible to show ALL tags of a file. But let's see what's left to show. The options dialog The options dialog gives you all options you would expect in a mpd client. You can change all modes, enable/disable outputs, set crossfade or toggle replaygain. In addition it's possible to start/stop mpdscribble. This works for either local or remote mpdscribbles (set in config file). Right now it kills or start mpdscribble. Hopefully mpdscribble will receive an option to suspend scrobbling itself via the client protocol. We will see :) Ratings UPDATE The ratings system is using mpds sticker database now, so ratings work for every filetype. Everything else remains the same, flat files for portability. One feature in clerk not found elsewhere is the ability to rate albums or tracks. Personally I don't do track ratings, but in my tests it worked fine for flac and mp3 files. Vorbis files are not yet implemented. It's just a pain to update vorbis tags. So I will only speak about the albumratings now. First of all, ratings need local access to the music directory. I wanted a way that is 100% portable and absolutely NOT tied to a musicplayer. This rules out mpd's sticker database, which seems hardly maintained anyway. Tags would be another obvious choice, but it's still not accessible enough for my taste. So the way I created ratings is by saving a ratings file to the album folder. That's all. A tiny text file containing the actual rating in the first line and some basic information (artist, date, album) afterwards. Clerk can even load albums by ratings. To make this happen I use bash's globbing mode which can very fast wander through the filesystem. Then I only need to grep for ratings in all text files and voila: It works. Mildly related I already wrote about musiclist.py This little script uses the ratings file and mpd itself to create a nice table of all albums, including ratings. Thanks to thor77 this now shows some very nice Stars instead of plain numbers. You can see the result here: musiclist The rest Apart from those features clerk offers basic controls (Play, Stop, Next, Prev, Clear) and lookup of lyrics, artists, albums (using surfraw). Last but not least every single dialog is available via cli arguments to quickly bind your favorite features to hotkeys. See all available arguments with clerk -h If you want to try it out, you can find it on github, together with mppc: github To get the most out of it, you really should get the excellent rofi tool by DaveDavenport: rofi","loc":"https://journal.53280.de/clerk-mpd-client-that-needs-typing.html","title":"clerk - mpd client that needs typing"},{"tags":"computer","text":"Python to the rescue I love my CD collection. I needed months to rip all my CDs into flac format and tagging it all correctly will probably never be finished. But what use is the biggest collection if you cannot show off? So I wanted a script that makes a nice html table of my music. And ideally it uses MPD since that has an index of my music anyway. So I started fiddling with bash and mpc only to find out that mpc is too limited to reach my goal. At least not in a performant way. So the aproach I originally took was to use metaflac to scan my collection and create a html table from that. This is how it looks: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/bin/bash echo '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\"> <head> <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /> <meta name=\"robots\" content=\"noindex\" /> <title>My Music</title> <style type=\"text/css\"><!--body {font-family:arial;font-size: medium;color: #3D3D3D;}table.tablesorter {background-color: #CDCDCD; align=\"center\"; margin: 0px auto;text-align: left;width: 50%;}table.tablesorter thead tr th, table.tablesorter tfoot tr th {background-color: #e6EEEE;border: 1px solid #FFF;font-size: medium;padding: 4px;}table.tablesorter thead tr .header {background-image:url(data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw%3D%3D);background-repeat: no-repeat;background-position: center right;cursor: pointer;}table.tablesorter tbody td {color: #3D3D3D;padding: 4px;background-color: #FFF;vertical-align: top;}table.tablesorter tbody tr.odd td { background-color:#F0F0F6; }table.tablesorter thead tr .headerSortUp { background-image:url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjB+gC+jP2ptn0WskLQA7); }table.tablesorter thead tr .headerSortDown { background-image:url(data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjI8Bya2wnINUMopZAQA7); }table.tablesorter thead tr .headerSortDown, table.tablesorter thead tr .headerSortUp {background-color: #8dbdd8; }--></style> </head> <body> <script type=\"text/javascript\" src=\"jquery.min.js\"></script> <script type=\"text/javascript\" src=\"jquery.tablesorter.js\"></script> <script type=\"text/javascript\"><!-- --></script> <table id=\"music\" class=\"tablesorter\" margin-{left,right}: auto;> <thead> <tr> <th>Artist</th> <th>Album</th> <th>Ratings</th> </tr> </thead> <tbody>' me = \" ${ 0 ##*/ } \" if [ $# -eq 0 -o \" $1 \" = '-h' -o \" $1 \" = '--help' -o ! -d \" $1 \" ] ; then echo \"Usage: $me /path/to/flacs\" 1> & 2 exit 1 fi fdir = \" $1 \" if [ -z \" $TMPDIR \" ] ; then TMPDIR = '/tmp' ; fi tdir = \" $( mktemp -d \" ${ TMPDIR } / ${ me } .XXXXXXXX\" ) \" if [ -z \" $tdir \" ] ; then echo \" $me : error: mktemp failed.\" 1> & 2 exit 1 fi lastDir = '' while read f ; do if [ ! -f \" $f \" ] ; then continue ; fi currentDir = \" ${ f %/* } \" if [ \" $currentDir \" = \" $lastDir \" ] ; then continue ; fi lastDir = \" $currentDir \" shopt -qs nocasematch artist = '' albumArtist = '' album = '' year = '0000' while read line ; do case \" $line \" in artist = * ) artist = \" ${ line #*= } \" ;; albumartist = * | album*artist = * ) albumArtist = \" ${ line #*= } \" ;; album = * ) album = \" ${ line #*= } \" ;; date = * ) year = \" ${ line #*= } \" ;; esac done < < ( metaflac --export-tags-to = - \" $f \" 2>/dev/null ) shopt -qu nocasematch if [ -z \" $albumArtist \" -a -z \" $artist \" ] ; then continue ; fi if [ -z \" $albumArtist \" ] ; then albumArtist = \" $artist \" ; fi if [ -z \" $album \" ] ; then continue ; fi artistHash = \" $( echo -n \" $albumArtist \" | md5sum - | cut -d ' ' -f 1 ) \" if [ ! -d \" ${ tdir } / ${ artistHash } \" ] ; then echo \" ${ artistHash } ${ albumArtist } \" >> \" ${ tdir } /artists\" mkdir \" ${ tdir } / ${ artistHash } \" fi rating = '-' if [ -f \" ${ currentDir } /../../rating.txt\" ] ; then read rating < \" ${ currentDir } /../../rating.txt\" elif [ -f \" ${ currentDir } /../rating.txt\" ] ; then read rating < \" ${ currentDir } /../rating.txt\" elif [ -f \" ${ currentDir } /rating.txt\" ] ; then read rating < \" ${ currentDir } /rating.txt\" fi echo \" $year $rating $album \" >> \" ${ tdir } / ${ artistHash } /albums\" done < < ( find \" $fdir \" -type f -iname '*.flac' 2>/dev/null | sort -u ) while read artistHash artist ; do rowspan = \" $( sort -u \" ${ tdir } / ${ artistHash } /albums\" 2>/dev/null | wc -l 2>/dev/null ) \" echo \"<tr>\" echo \" <td rowspan=\" $rowspan \"> ${ artist //&/&amp; } </td>\" while read year rating album ; do echo \" <td> $year ${ album //&/&amp; } </td>\" echo \" <td><font color=red> ${ rating } </font></td>\" echo \"</tr>\" done < < ( sort -u \" ${ tdir } / ${ artistHash } /albums\" 2>/dev/null ) done < < ( sort -u -k 2 \" ${ tdir } /artists\" 2>/dev/null ) echo \"</tbody></table> <p> <a href=\" http://validator.w3.org/check?uri = referer \"><img src=\" http://www.w3.org/Icons/valid-xhtml10 \" alt=\" Valid XHTML 1.0 Strict \" height=\" 31 \" width=\" 88 \" /></a> </p> </body></html>\" rm -rf \" $tdir \" This worked perfectly but it had a drawback. Original music that I purchased from amazon and other sources could not be read by metaflac. Using mutagen could have been another option, but I really prefer to do my stuff with MPD :) rob``, python and performance rob`` from the german arch linux IRC channel was so kind to create this really neat python script which does exactly what I wanted: Get all artists and their albums and create a nice html table. In addition it also scans my album ratings (created with my mpdmenu ) and puts them in another column. After some css tweaking the script was done in a few minutes. The above bash script which uses metaflac takes about 1 minute to finish the table. My tries with bash+mpc needed at least 20 minutes (!). This very script now needs around 30 seconds. Not too bad :) Anyway here is the script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python2 from __future__ import print_function import os import operator import re import mpd # pacman -S python2-mpd MUSIC_ROOT = '/mnt/wasteland/Audio/Rips' RATING_FILE = 'rating.txt' def query ( c , * items , ** conditions ): if conditions : # turn dict into flattened list, e.g. # {k1: v1, k2: v2} -> [k1, v1, k2, v2] cond = reduce ( operator . add , conditions . items ()) results = c . find ( * cond ) else : results = c . listallinfo () yielded = set () for r in results : d = [] for i in items : it = r . get ( i ) if isinstance ( it , list ): it = it [ 0 ] d . append ( it ) d = tuple ( d ) if all ( d ) and d not in yielded : yield d yielded . add ( d ) def get_artists ( c ): a = [ r [ 0 ] for r in query ( c , 'albumartist' )] return a def get_rating ( c , artist , date , album ): r = query ( c , 'file' , albumartist = artist , date = date , album = album ) path = next ( r )[ 0 ] path = os . path . join ( MUSIC_ROOT , path ) path = os . path . dirname ( path ) if re . search ( \"CD ?\\d\" , path , flags = re . IGNORECASE ): path = os . path . dirname ( path ) path = os . path . join ( path , RATING_FILE ) try : with ( open ( path )) as f : rating = f . readline () . strip () return rating except IOError : return \"-\" def main (): c = mpd . MPDClient () host = os . environ . get ( 'MPD_HOST' , 'localhost' ) port = os . environ . get ( 'MPD_PORT' , '6600' ) pw = None if \"@\" in host : pw , host = host . split ( \"@\" ) c . connect ( host , port ) if pw is not None : c . password ( pw ) print ( \"<html>\" ) print ( \"<head><meta charset= \\\" utf-8 \\\" /><link rel= \\\" stylesheet \\\" href= \\\" //netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css \\\" ><style>body{background:#eee}table{margin:5em auto; max-width:56em; background: white;}</style></head>\" ) print ( \"<body>\" ) print ( \"<div class= \\\" table-responsive \\\" >\" ) print ( \"<table id= \\\" music \\\" class= \\\" table table-bordered \\\" >\" ) print ( \"<thead>\" ) print ( \"<tr><th>Artist</th><th>Year</th><th>Album</th><th>Rating</th></tr></thead><tbody>\" ) for artist in sorted ( get_artists ( c ), key = lambda v : ( v . upper (), v [ 0 ] . islower ())): albums = sorted ( query ( c , 'date' , 'album' , albumartist = artist )) print ( '<tr class= \\\" newartist \\\" ><td rowspan=\"{0}\">{1}</td>' . format ( len ( albums ), artist )) for i , ( date , album ) in enumerate ( albums ): rating = get_rating ( c , artist , date , album ) # templating libraries ftw print ( \"<td>{}</td>\" . format ( date )) print ( \"<td>{}</td>\" . format ( album )) print ( \"<td><font color= \\\" red \\\" >{}</td>\" . format ( rating )) print ( \"</tr>\" ) print ( \"</table></div>\" ) if __name__ == '__main__' : main () The Result And here is how the generated html will look like","loc":"https://journal.53280.de/albumlist_creator.html","title":"Create html list of all your albums"},{"tags":"computer","text":"This article is obsolete.... read on HERE ... Introduction I am a fan of dmenu . I think it's incredibly useful and fast for a lot of tasks. Recently DaveDavenport forked simpleswitcher and renamed it to rofi . Why do I mention it? Well he added a dmenu mode to it, which makes it 100% compatible with the latter. Nice! It's also no secret that I am a MPD advocate. What it does it does perfectly - the server/client design makes it's nothing but ideal for a home stereo system. So I thought why not combine these 2 worlds and control MPD in the fastest way imaginable? So I wrote mpdMenu - a dmenu based MPD client. Yes there are others out there already, but none of these do, what mpdMenu does - trust me on that one. Features So what makes it special? The dmenu-based MPD clients you can find on the web normally do one thing: browse your Playlist (or maybe the database) and select some songs/albums to play. That's cool, but I wanted more than that. So mpdMenu has 4 modes to add, insert or replace music. Artist - Browse Artists and add/play all their music Albums - Chose any album and add/play it. Track - Search for any track and add/play it. Database Browser - Browse Database by Artist > Album > Track and add/play whatever you chose. Believe me, espacally the 3rd part is a blessing. It never was that easy and that fast to play a specific song. Don't believe me? Have a look yourself: {% video ./images/mpd_track.mp4 800 450 https://pic.53280.de/mpd.png %} It works around the same for the other modes too. Handling what's on your queue Sometimes you want to hear more from the currently playing artist. That's why I added a submenu which does just this. Selecting the \"Current Artist\" Option will present you a menu which will let you add tracks or albums by the Artist that is currently playing. Last but not least mpdMenu allows you to browse the current Queue and switch songs. Just play something! But sometimes you simply don't know what you want to listen to. For these ocasions I added 2 modes. Random Album Random Tracks They do exactly what they say. For random tracks the script will ask you how many items you want to get added to your playlist. Options The Options Menu presents you with most MPD options that can be switched on the fly. This includes changing the volume, enabling modes (random, single, consume, repeat), changing replaygain, enabling/disabling audio outputs and setting crossfading. It also includes a submenu called lastfm, which allows to start and stop mpdscribble. It also can add/remove currently playing artists to a blacklist so they will never be scrobbled. At the moment the lastfm functionality calls an external script, because the code for the blacklist is relatively ugly :) Rating My personal Highlight is the Rating Menu. Here you can rate albums and tracks and search your database by rated tracks. This is done in 2 different ways. For tracks I use an external tagger (python-eyed3) to add a comment field to the files which includes the rating. In theory I could have used the same way for albums too, but MPD cannot handle several comment fields, so I had to be clever. So if you rate an album, mpdMenu will create a tiny text file inside of the album directory which includes Artist, Album and Rating. When searching for album ratings bash's globbing is used to magically find the relevant information. It works really well: {% video ./images/mpd_rating.mp4 800 450 https://pic.53280.de/mpd.png %} Where to get it You can find the little script in my git repository","loc":"https://journal.53280.de/mpdMenu.html","title":"mpdMenu - mpd on stereoids"},{"tags":"computer","text":"In my neverending journey to find the optimal windowmanager, I finally ended up trying herbstluftwm, which i wanted to give a shot for ages. Turned out to be a good choice. But wait. What makes herbstluftwm different from the gazillion other windowmanagers out there? Let's dive into it. The config file... ...which really is no config file at all. You see, in herbstluftwm everything is done through a helper binary called herbstclient. You want to resize a window? You call something like herbstclient resize right +0.05 The same thing applies to every other possible action. So the config file is really just a set of herbstclient commands that sets the initial state of the windowmanager. This includes things like number of workspaces (and names for them too), layout for individual workspaces, placement rules for applications, as well as theming and keybindings. Here is my example config file (which is appropriately called \"autostart\"): #!/bin/bash # this is a simple config for herbstluftwm function hc () { herbstclient \" $@ \" } hc emit_hook reload #xsetroot -solid '#5A8E3A' # remove all existing keybindings hc keyunbind --all # keybindings Mod = Mod4 hc keybind $Mod -z floating toggle hc keybind $Mod -Shift-q quit hc keybind $Mod -Shift-r reload hc keybind $Mod -k close hc keybind $Mod -Return spawn termite --role = term /bin/zsh hc keybind $Mod -Shift-Return spawn termite /bin/zsh hc keybind Print spawn teiler hc keybind $Mod -Shift-s spawn termite --role = ssh -e karif hc keybind $Mod -Shift-F12 spawn lastfm.sh switch hc keybind $Mod -F12 spawn lastfm.sh check hc keybind $Mod -Shift-F11 spawn love hc keybind $Mod -Tab spawn simpleswitcher -now hc keybind $Mod -p spawn dmenu_run # tags TAG_NAMES =( { terms,www,stuff,media,dl,gfx } ) TAG_KEYS =( { 1..9 } 0 ) hc rename default \" ${ TAG_NAMES [0] } \" || true for i in ${ !TAG_NAMES[@] } ; do hc add \" ${ TAG_NAMES [ $i ] } \" key = \" ${ TAG_KEYS [ $i ] } \" if ! [ -z \" $key \" ] ; then hc keybind \" $Mod - $key \" use \" ${ TAG_NAMES [ $i ] } \" hc keybind \" $Mod -Shift- $key \" move \" ${ TAG_NAMES [ $i ] } \" fi done # cycle through tags hc keybind $Mod -period use_index +1 --skip-visible hc keybind $Mod -comma use_index -1 --skip-visible hc keybind $Mod -Right focus right hc keybind $Mod -Left focus left hc keybind $Mod -Up focus up hc keybind $Mod -Down focus down hc keybind $Mod -Shift-Right shift right hc keybind $Mod -Shift-Left shift left hc keybind $Mod -Shift-Up shift up hc keybind $Mod -Shift-Down shift down # layouting hc keybind $Mod -r remove hc keybind $Mod -space cycle_layout 1 hc keybind $Mod -v split vertical 0.5 hc keybind $Mod -h split horizontal 0.5 hc keybind $Mod -Shift-v split vertical 0.3 hc keybind $Mod +Shift+h split horizontal 0.3 hc keybind $Mod -s floating toggle hc keybind $Mod -f fullscreen toggle hc keybind $Mod -Shift-p pseudotile toggle # resizing RESIZESTEP = 0.05 hc keybind $Mod -Control-Left resize left + $RESIZESTEP hc keybind $Mod -Control-Down resize down + $RESIZESTEP hc keybind $Mod -Control-Up resize up + $RESIZESTEP hc keybind $Mod -Control-Right resize right + $RESIZESTEP # mouse hc mouseunbind --all hc mousebind $Mod -Button1 move hc mousebind $Mod -Button2 resize hc mousebind $Mod -Button3 zoom # focus hc keybind $Mod -BackSpace cycle_monitor #hc keybind $Mod-Tab cycle_all +1 #hc keybind $Mod-Shift-Tab cycle_all -1 hc keybind $Mod -c cycle hc keybind $Mod -i jumpto urgent hc keybind $Mod -KP_Left shift left hc keybind $Mod -KP_Down shift down hc keybind $Mod -KP_Right shift right hc keybind $Mod -KP_Up shift up # colors hc set frame_border_active_color '#82B414' hc set frame_border_normal_color '#0c0d0e' hc set frame_bg_normal_color '#121212' hc set frame_active_opacity 90 hc set frame_normal_opacity 70 hc set frame_bg_active_color '#121212' hc set frame_bg_transparent 0 hc set frame_border_width 1 hc set window_border_width 1 hc set window_border_inner_width 3 hc set window_border_normal_color '#454545' hc set window_border_active_color '#0c73c2' hc set always_show_frame 1 hc set frame_gap 2 # add overlapping window borders hc set window_gap 2 hc set frame_padding 0 hc set smart_window_surroundings 1 hc set smart_frame_surroundings 1 hc set mouse_recenter_gap 0 hc set focus_follows_mouse 1 hc set raise_on_focus 1 hc pad 5 5 5 5 5 # rules hc unrule -F #hc rule class=XTerm tag=3 # move all xterms to tag 3 hc rule focus = on # normally do not focus new clients # give focus to most common terminals hc rule class~ '(.*[Rr]xvt.*|.*[Tt]erm|Konsole)' focus = on hc rule windowtype~ '_NET_WM_WINDOW_TYPE_(DIALOG|UTILITY|SPLASH)' pseudotile = on hc rule windowtype = '_NET_WM_WINDOW_TYPE_DIALOG' focus = on hc rule windowtype~ '_NET_WM_WINDOW_TYPE_(NOTIFICATION|DOCK)' manage = off hc rule class = Firefox tag = www hc rule windowrole = term tag = terms hc rule windowrole = ssh tag = terms # unlock, just to be sure hc unlock herbstclient set tree_style '╾│ ├└╼─┐' # do multi monitor setup here, e.g.: # hc set_monitors 1280x1024+0+0 1280x1024+1280+0 # or simply: # hc detect_monitors # find the panel panel = ~/.config/herbstluftwm/panel.sh [ -x \" $panel \" ] || panel = /etc/xdg/herbstluftwm/panel.sh for monitor in $( herbstclient list_monitors | cut -d: -f1 ) ; do # start it on each monitor $panel $monitor & done # GIMP # ensure there is a gimp tag hc load gfx ' (split horizontal:0.850000:0 (split horizontal:0.200000:1 (clients vertical:0) (clients grid:0)) (clients vertical:0)) ' # load predefined layout # center all other gimp windows on gimp tag hc rule class = Gimp tag = gfx index = 01 pseudotile = on hc rule class = Gimp windowrole~ 'gimp-(image-window|toolbox|dock)' \\ pseudotile = off hc rule class = Gimp windowrole = gimp-toolbox focus = off index = 00 hc rule class = Gimp windowrole = gimp-dock focus = off index = 1 All the available commands are explained in the manpage of herbstluftwm. But the last bit needs some special attention. layouts The nice thing about herbstluftwm, compared to e.g. i3 is that you can predefine layouts per workspace. Watch the code again: # GIMP # ensure there is a gimp tag hc load gfx ' (split horizontal:0.850000:0 (split horizontal:0.200000:1 (clients vertical:0) (clients grid:0)) (clients vertical:0)) ' # load predefined layout center all other gimp windows on gimp tag hc rule class = Gimp tag = gfx index = 01 pseudotile = on hc rule class = Gimp windowrole~ 'gimp-(image-window|toolbox|dock)' \\ pseudotile = off hc rule class = Gimp windowrole = gimp-toolbox focus = off index = 00 hc rule class = Gimp windowrole = gimp-dock focus = off index = 1 This makes sure that we create 3 \"tiles\" on a workspace called \"gfx\". Then it creates rules based on the gimp windows, so that each gimp window will be put into the desired tile. This will result in this: That's really nice, isn't it? The best part is you don't have to fiddle with this by try and error. simply resize your windows the way you want them to be and run herbstclient dump gfx where gfx is the workspace name (or tag). This will output the desired string which you can either use manually like i did in my gimp example, or you use the command: herbstclient load \" $( cat DUMP_FILE ) \" frames vs. windows The thing about herbstluftwm that is most obviously different from other windowmanagers is probably the added layer called \"frames\". Where you simply tile windows in other windowmanagers, you create frames in herbstluftwm. Inside of these frames you finally start your applications. Each frame can be tiled individually. This is best explained with a screenshot: Have a look at the upper right corner. There are 4 terminal windows. The active one has a blue border. But look outside of those 4 windows. There is another border - green in my case. This marks the frame. Inside of this you can have as many open windows as you wish and tile them in different ways (splith, splitv, grid, maximized). The terminal window on the lower right is another frame. Since its a single window it would only receive a green outline when focused. The 2 terminals on the left are another frame. This adds a bit of complexibility but is quite flexible too. panels Another nice thing about hlwm is the way it handles panels. Hlwm has an inbuilt margin feature to preserve space for panels. This way I could easily make sure that my xfce4-panel works flawlessly. When you watch my config file above you probably noticed that it calls a script named \"panel.sh\". The default panel.sh script sets some variables which are finally piped to dzen2. That's rather nice, but it's missing a systemtray. In addition to this current dzen2 has a bug which makes clickable workspaces non-functional. So i created a very minimal panel.sh which only loads my xfce4-panel: #!/bin/bash monitor = ${ 1 :- 0 } panel_height = 16 herbstclient pad $monitor $panel_height That's all. xfce4-panel works perfectly, thanks to the \"panel_height\" option. floating Most tiling window managers have a special layer for floating windows. Windows that float will simply be shown on top of your other windows. Herbstluftwm does not know the concept of a special floating layer. It's either all floating or all tiled, but you can switch between these modes with one keystroke. As a workaround herbstluftwm includes a mode called \"pseudotile\". Applications that are tagged to be pseudotiled (in default config this includes all dialogs), will simply be tiled too, but still they are floating. kind of. Let's show: As you can see the dialog is in a regular tile (50% vertical split) but still its dimensions are kept. While this works ok for some apps, it works bad for others. Luckily a proper floating layer will be added to hlwm in the future, but the developers are not sure yet how it will look/work in the end. conclusion Herbstluftwm is a very nice window manager. The configuration is dead easy, a simple bash (perl,python,etc) file which calls a bunch of herbstclient commands. Little things are taken care of, like the margin feature for panels. Did I mention that hlwm supports compositing out of the box? Well, it does. But the best part: Its constantly being worked on and has several contributors, which is a very good sign for a free software project.","loc":"https://journal.53280.de/herbstluftwm.html","title":"Herbstluftwm"},{"tags":"Computer","text":"Bugs! They are Everywhere! After a few weeks of usage fluxbox turned out to be really nice - but at the same time it turned its nasty second face towards me, screaming \"BUGS!\" all the time. If you have read my last post, you could already see some of it in there. To make other panels work correctly, you need a patch. Positioning of windows is buggy, its nearly impossible to place windows pixel perfect on screen via rules. In worst case the same MoveTo command reacts differently each time, resulting in slight jumpings of the windows. No major issue, but it left the feeling of hackish, uncomplete software - even tho everything worked so far. Multihead also doesn't work as it should - fluxbox freezes when plugging in another monitor. While this does not affect me yet, I am planning to buy another screen soon, so I was looking for a viable alternative with better multihead support. I looked for alternatives to clone my subtle/fluxbox setup once again. Only viable options were pekwm and openbox, which I simply don't want to use. PekWM for some nasty bugs and openbox for its configuration. So I headed back to the world of real tiling WMs. I wanted an easy-to-use config file, which - frankly - only left 2 possible candidates: i3 and herbstluftwm. For now I decided to go with i3, since I had some experiences with it. But I always wanted to play with hlwm too - maybe next month :). Say hello to i3! So whats in i3? Well, primary it offers some easy to understand workflow. First of all, i3 is not as manual as subtle is. Windows get split automatically. Open a 2nd window and both windows will fill 100% of your screen. Either split (horizontally or vertically), tabbed or cascaded (same as tabbed, but window titles are above each other, instead side-by-side). With each window you open, another split is created - once again - horizontally or vertically. Thats all there is to window management, really. But it has some nice features which make using it a joy: The Scratchpad The concept of a scratchpad is not new. Basically a window that is in a scratchpad can be hidden/shown at any time on any workspace. But i3 goes a little further. You can have as many windows in your scratchpad as you like and show only the one you want with one keystroke. Configuration of this is easy: bindsym $mod+Mod1+1 [class=\"xv|MPlayer\"] scratchpad show This will create a hotkey to show any window in scratchpad that matches the given class - in this case MPlayer. You can also have windows opened directly in scratchpad. Useful for tools you want to have open all the time, but not visible - and they lack a tray icon. Example keepassx: Marks and Jumps Another nice feature are Jumps and Marks. Both basically do the same thing. You have a hotkey that takes you to a specific app. With jumps all you have to do is this: bindsym $mod+Control+1 [window_role=\"ssh\"] focus This will instantly focus my terminal with WINDOW_ROLE \"ssh\" when hitting the hotkey. On whatever workspace/screen this window may be. Pretty neat. Marks basically do the very same thing, but they tag the windows. To make things a little more convinient I got myself some little i3 scripts that handle this with help of the wonderful dmenu. The scripts are available here. Set up the scripts in your i3 config: bindsym $mod+Shift+g exec $HOME/bin/i3/mark bindsym $mod+g exec $HOME/bin/i3/goto Now you can tag a window with mod+g and show available tags with mod+shift+g. This will look like this: Setting a mark Searching for a mark As you can see, this gives you a nice dmenu styled application choser, which only shows your tagged windows. While jumps are quicker to use, marks are simpler, as you dont have to remember which hotkey you associated with what application. Modes This is a very clever way of having specific tasks in a vim like fashion. It 100% integrates into your panel. Basically this gives you chained keybindings with a visual clue. i3 comes with one mode by default: Resize mode. Hitting the appropriate keybind will show a red \"Resize\" in your bar. This tells you that normal hotkeys won't work at this moment. Instead you can only use defined hotkeys to trigger actions. In case of resize mode these are the movement keys to make splits/windows smaller/bigger. Pretty neat. I created (stole) myself a custom mode, that prompts the user for logout options. Code follows: # Create Log out, Reboot, Poweroff bindingsmode \"(E)xit, (R)eboot, (P)oweroff\" { bindsym r exec systemctl reboot bindsym e exit bindsym p exec systemctl poweroff# back to normal: Enter or Escapebindsym Return mode \"default\" bindsym Escape mode \"default\" }bindsym $mod+Shift+e mode \"(E)xit, (R)eboot, (P)oweroff\" When hitting the hotkey (defined in last line) It will enter the mode and then the subset of hotkeys (r, e and p) can be used to trigger the defined actions. It looks like this: The Panel i3 comes with the i3-bar. It uses i3-status by default. While not particulary bad, its very limited in its usage. It comes with some widgets, but I dont need a single one of it. Luckily you can replace i3-status with dzen2 or conky or whatever you want to use to get text piped. So far nothing special, but i3 does this in a clever way: Workspaces and tray will remain visible, even if you disable i3-status. This way you can have the best of both worlds. So I simply set up a conky setup (which was not trivial, since i3 expects a custom syntax to know when a new field in conky begins - at least if you want colors) and the result suits me perfectly! Appendix Another little thing I noticed is, that moving windows (default mod+shift+movement keys) will not only change positions of tiled windows, but you can also use it to move floating windows across the screen, without the mouse. Havent seen this in other tilers yet, tho i never tried :) Finally, here my config: i3 config: #x This file has been auto-generated by i3-config-wizard(1) # It will not be overwritten, so edit it as you like. # # Should you change your keyboard layout somewhen, delete # this file and re-run i3-config-wizard(1). # # i3 config file (v4) # # Please see http://i3wm.org/docs/userguide.html for a complete reference! set $mod Mod4 # Font for window titles. Will also be used by the bar unless a different font # is used in the bar {} block below. ISO 10646 = Unicode font pango:Envy Code R 10 # The font above is very space-efficient, that is, it looks good, sharp and # clear in small sizes. However, if you need a lot of unicode glyphs or # right-to-left text rendering, you should instead use pango for rendering and # chose an xft font, such as: #font xft:DejaVu Sans Mono 10 # Use Mouse+$mod to drag floating windows to their wanted position floating_modifier $mod # start a terminal bindsym $mod+Return exec --no-startup-id termite /bin/zsh --role=roxterm bindsym $mod+Shift+Return exec --no-startup-id termite /bin/zsh --role=termrox # start ssh session bindsym $mod+Shift+s exec --no-startup-id termite --role=ssh -e karif #teiler bindsym Print exec $HOME/bin/teiler # kill focused window bindsym $mod+k kill # start dmenu (a program launcher) bindsym $mod+p exec dmenu_run -nb \"#000000\" -nf \"#a0a0a0\" -sb \"#0C73C2\" -sf \"#ffffff\" -fn 'Source Code Pro-12' # change focus bindsym $mod+Left focus left bindsym $mod+Down focus down bindsym $mod+Up focus up bindsym $mod+Right focus right bindsym $mod+Shift+Left move left bindsym $mod+Shift+Down move down bindsym $mod+Shift+Up move up bindsym $mod+Shift+Right move right # split in horizontal orientation bindsym $mod+h split h # split in vertical orientation bindsym $mod+v split v # enter fullscreen mode for the focused container bindsym $mod+f fullscreen # change container layout (stacked, tabbed, toggle split) bindsym $mod+s layout stacking bindsym $mod+w layout tabbed bindsym $mod+e layout toggle split # toggle tiling / floating bindsym $mod+Shift+space floating toggle # change focus between tiling / floating windows bindsym $mod+space focus mode_toggle # focus the parent container bindsym $mod+a focus parent # focus the child container #bindcode $mod+d focus child # switch to workspace bindsym $mod+1 workspace 1:terms bindsym $mod+2 workspace 2:www bindsym $mod+3 workspace 3:stuff bindsym $mod+4 workspace 4:media bindsym $mod+5 workspace 5:torrent bindsym $mod+6 workspace 6:gfx bindsym $mod+7 workspace 7 bindsym $mod+8 workspace 8 bindsym $mod+9 workspace 9 bindsym $mod+0 workspace NOTAG # move focused container to workspace bindsym $mod+Shift+1 move container to workspace 1:terms bindsym $mod+Shift+2 move container to workspace 2:www bindsym $mod+Shift+3 move container to workspace 3:stuff bindsym $mod+Shift+4 move container to workspace 4:media bindsym $mod+Shift+5 move container to workspace \"5:torrent\" bindsym $mod+Shift+6 move container to workspace 6:gfx bindsym $mod+Shift+7 move container to workspace 7 bindsym $mod+Shift+8 move container to workspace 8 bindsym $mod+Shift+9 move container to workspace 9 bindsym $mod+Shift+0 move container to workspace NOTAG # Scratchpad hotkeys: # Make the currently focused window a scratchpad bindsym $mod+Shift+minus move scratchpad # Show the first scratchpad window bindsym $mod+minus scratchpad show # Show the sup-mail scratchpad window, if any. bindsym $mod+Mod1+1 [class=\"mplayer2\"] scratchpad show # reload the configuration file bindsym $mod+Shift+c reload # restart i3 inplace (preserves your layout/session, can be used to upgrade i3) bindsym $mod+Shift+r restart # exit i3 (logs you out of your X session) bindsym $mod+Shift+y exec \"i3-nagbar -t warning -m 'Choose:' -b 'Exit i3' 'i3-msg exit' -b 'Reboot' 'i3-msg exec systemctl reboot' -b 'Poweroff' 'i3-msg exec systemctl poweroff'\" # Create Log out, Reboot, Poweroff bindings mode \"(E)xit, (R)eboot, (P)oweroff\" { bindsym r exec systemctl reboot bindsym e exit bindsym p exec systemctl poweroff # back to normal: Enter or Escape bindsym Return mode \"default\" bindsym Escape mode \"default\" } bindsym $mod+Shift+e mode \"(E)xit, (R)eboot, (P)oweroff\" # resize window (you can also use the mouse for that) mode \"resize\" { # These bindings trigger as soon as you enter the resize mode # Pressing left will shrink the window's width. # Pressing right will grow the window's width. # Pressing up will shrink the window's height. # Pressing down will grow the window's height. bindsym j resize shrink width 10 px or 10 ppt bindsym k resize grow height 10 px or 10 ppt bindsym l resize shrink height 10 px or 10 ppt bindsym odiaeresis resize grow width 10 px or 10 ppt # same bindings, but for the arrow keys bindsym Left resize shrink width 10 px or 10 ppt bindsym Down resize grow height 10 px or 10 ppt bindsym Up resize shrink height 10 px or 10 ppt bindsym Right resize grow width 10 px or 10 ppt # back to normal: Enter or Escape bindsym Return mode \"default\" bindsym Escape mode \"default\" } bindsym $mod+r mode \"resize\" # Start i3bar to display a workspace bar (plus the system information i3status # finds out, if available) bar { colors { background #000000 statusline #ffffff focused_workspace #0C73C2 #0C73C2 #ffffff #000000 active_workspace #0C73C2 #0C73C2 #ffffff #000000 inactive_workspace #333333 #222222 #888888 urgent_workspace #2f343a #900000 #ffffff } status_command $HOME/bin/conky-i3bar position top # mode hide } # colors #client.focused.border #ffffff #ffffff client.focused #0C73C2 #0C73C2 #ffffff #0C73C2 client.background #000000 #client.focused.background #000000 new_window pixel 2 popup_during_fullscreen smart force_display_urgency_hint 500 ms # rules assign [class=\"Aurora|Firefox|Navigator|Opera|Chromium|dwb\"] 2:www assign [class=\"Spacefm\"] 3:stuff assign [class=\"Transmission-remote-gtk\"] 5:torrent assign [class=\"Keepassx\"] 9 assign [class=\"Spotify\"] 4:media assign [instance=\"roxterm\"] 1:terms assign [class=\"Gimp\"] 6:gfx #window rules for_window [class=\"&#94;xv|mplayer2|Steam|Wine\"] floating enable for_window [title=\"PlayOnLinux\"] floating enable ##jump commands #focus ssh window bindsym $mod+F1 [instance=\"ssh\"] focus #mark for_window [instance=\"ssh\"] mark karif for_window [class=\"Aurora|Firefox|Navigator|Chromium\"] mark browser bindsym $mod+Shift+g exec $HOME/bin/i3/mark bindsym $mod+g exec $HOME/bin/i3/goto bindsym $mod+Shift+F9 exec i3-input -F 'mark %s' -l 1 -P 'Mark: ' bindsym $mod+Tab exec $HOME/bin/i3-windows bindsym $mod+Shift+F5 exec translate en bindsym $mod+F5 exec translate de ### mpd keybindings bindsym XF86AudioPlay exec mpc toggle bindsym XF86AudioStop exec mpc stop bindsym XF86AudioNext exec mpc next bindsym XF86AudioPrev exec mpc prev bindsym Shift+XF86AudioNext exec mpc seek +5 bindsym Shift+XF86AudioPrev exec mpc seek -5 bindsym $mod+Shift+F12 exec --no-startup-id ~/bin/lastfm.sh switch bindsym $mod+F12 exec --no-startup-id ~/bin/lastfm.sh check bindsym $mod+F11 exec --no-startup-id ~/bin/love","loc":"https://journal.53280.de/another-month-another-window-manager.html","title":"Another Month - Another Window Manager"},{"tags":"computer","text":"So partly because I was bored, partly because subtle doesn't work very well with both qt and gtk3, i decided to fiddle around with fluxbox a bit. My goal was to make it behave as closely to my subtle setup as possible. Of all the *box WMs I only ever used openbox properly before. And while theoretically possible, I soon gave up porting my subtle config to it. XML is just such a mess. Really, whoever thought XML is suitable for config files is nuts. So back to fluxbox. It turned out that setting it up is very straight forward. There are a handful of files you want to look at more closely: ~/.fluxbox/init this file stores the general options, like focus model, enable/disable tabs, settings for the internal panel. Most of it is pretty obvious stuff. ~/.fluxbox/keys This is where the fun starts. In this file you set up all your key bindings. Nothing special, every WM does this. But there is a but. Fluxbox has some unique ways that make it the optimal choice for my plan. So what did I actually want? In my subtle setup I had a few hotkeys, that move windows to one of the 4 corners on screen or fill up half the screen either horizontally or vertically. MacroCmd to the rescue! Of course fluxbox supports positioning windows and resizing windows, but what if you want to have both things without strictly tagging windows? (to retain flexibility) The solution is actually pretty easy: Mod4 KP_1 :MacroCmd {ResizeTo 945 500} {MoveTo 4 4 LowerLeft} {Raise} {Focus} This will move the current window to the upper left corner and resize it to fill 25% of my screen. Percentage values are also possible, tho less exact. Another thing I had in my subtle setup was the ability to start terminal windows instantly at specified areas (matching my grid to move windows around) To do this you have to give your terminal a proper name. For urxvt you can use the -name argument, for xfce4-terminal –role=foo will work. With these unique names we can now tag all windows matching those. Which leads us to: ~/.fluxbox/apps the apps file is very simple to use. Lets see an example: [app] (role=term_top_left) [Dimensions] {945 500} [Position] (UPPERLEFT) {4 4}[Workspace] {0} [Deco] {BORDER} [Alpha] {245 230} [end] Pretty obvious, once you have seen it. The last line is particulary interesting tho: It sets transparency values based based on active state of the window. I don't know any other WM that has such an option. Pretty neat if you want some eyecandy! Apart from this the apps file normally is used to simply set a workspace for an application. Unlike subtle, fluxbox never forces the workspace tho, you are free to move your windows everytime. Anyway, basic setup was complete, now all that was left was to clone subtle's panel, which seemed like an impossible task. Fluxbox internal panel is far too limited, so I gave xfce4-panel another try - and was surprised how good you can make it look - using more or less nothing but generic command widgets :) Fluxbox doesn't work too well with xfce4-panel, maximized windows will cover it. Luckily I found a patch that works around this. For your convinience, here it is: patch Mandatory Screenshot","loc":"https://journal.53280.de/fluxbox-with-manual-tiling.html","title":"Fluxbox with manual tiling"}]}